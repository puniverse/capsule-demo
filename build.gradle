apply plugin: 'java'
apply plugin:'application'

sourceCompatibility = '1.8'
targetCompatibility = '1.8'

[compileJava, compileTestJava]*.options*.encoding = 'UTF-8'

mainClassName = "foo.Main"

group       = "co.paralleluniverse"
version     = "0.2.0"
status      = "integration"
description = "A demo using Capsule"

repositories {
    mavenLocal()
    mavenCentral()
}

configurations {
    capsule
    quasar
    provided
}

sourceSets {
    main.compileClasspath = main.compileClasspath + configurations.provided
    test.compileClasspath = test.compileClasspath + configurations.provided
    test.runtimeClasspath = test.runtimeClasspath + configurations.provided
}

dependencies {
    capsule 'co.paralleluniverse:capsule:0.9.0'
    provided 'co.paralleluniverse:capsule:0.9.0'
    compile ('co.paralleluniverse:quasar-core:0.6.0:jdk8')  {
        exclude group: 'org.slf4j', module: '*'
        exclude group: 'org.apache.logging.log4j', module: '*'
        exclude group: 'org.apache.ant', module: '*'
    }
    compile "co.paralleluniverse:quasar-actors:0.6.0"
    quasar  "co.paralleluniverse:quasar-core:0.6.0:jdk8"
    testCompile group: 'junit', name: 'junit', version: '4.10'
}

tasks.withType(JavaExec) {
    standardInput = System.in

    jvmArgs '-server'
    jvmArgs "-javaagent:${configurations.quasar.iterator().next()}" // =vdmc (verbose, debug, allow monitors, check class)
    // systemProperty "co.paralleluniverse.fibers.DefaultFiberPool.parallelism", "4"
    systemProperty "co.paralleluniverse.fibers.DefaultFiberPool.monitor", "JMX" // "METRICS" // "NONE" //
    systemProperty "co.paralleluniverse.actors.moduleDir", "${rootProject.projectDir}/modules"

    // memory
    jvmArgs '-Xmx1024m'
}

apply plugin: 'maven'

task writePom << {
    pom {
        project {
            groupId 'com.acme'
            artifactId 'foo'
            version '1.0'
        }
    }.writeTo("$buildDir/pom.xml")
}

// creates a "thin" capsule with the dependencies listen in an embedded POM, rather than the manifest
task pomCapsule(type: Jar, dependsOn: [writePom, classes]) {
    archiveName = "foo.jar"
    from sourceSets.main.output // this way we don't need to extract the capsule
    from "$buildDir/pom.xml"
    from { configurations.capsule.collect { zipTree(it) } }

    manifest {
        attributes(
	    'Main-Class'  :   'Capsule',
            'Application-Class'   : mainClassName,
            'Extract-Capsule' : 'false',
            'Min-Java-Version' : '1.8.0',
            'JVM-Args' : run.jvmArgs.join(' '),
            'System-Properties' : run.systemProperties.collect { k,v -> "$k=$v" }.join(' '),
            'Java-Agents' : getDependencies(configurations.quasar).iterator().next(),
        )
    }
}

// converts Gradle dependencies into Capsule dependencies
def getDependencies(config) {
    return config.getAllDependencies().collect {
        def res = it.group + ':' + it.name + ':' + it.version + (!it.artifacts.isEmpty() ? ':' + it.artifacts.iterator().next().classifier : '')
        if(!it.excludeRules.isEmpty()) {
            res += "(" + it.excludeRules.collect { it.group + ':' + it.module }.join(',') + ")"
        }
        return res
    }
}

// creates a "thin" capsule, with the dependencies listen in the manifest
task capsule(type: Jar, dependsOn: classes) {
    archiveName = "foo.jar"
    from sourceSets.main.output // this way we don't need to extract
    from { configurations.capsule.collect { zipTree(it) } }

    manifest {
        attributes(
	    'Main-Class'  :   'Capsule',
            'Application-Class'   : mainClassName,
            'Extract-Capsule' : 'false',
            'Min-Java-Version' : '1.8.0',
            // 'Args' :     'hello world',
            'JVM-Args' : run.jvmArgs.join(' '),
            'System-Properties' : run.systemProperties.collect { k,v -> "$k=$v" }.join(' '),
            'Java-Agents' : getDependencies(configurations.quasar).iterator().next(),
            'Dependencies': getDependencies(configurations.runtime).join(' ')
        )
    }
}

// creates a "fat" capsule, with all dependencies embedded in the capsule
task fatCapsule(type: Jar, dependsOn: jar) {
    archiveName = "foo.jar"

    from(configurations.capsule.collect { zipTree(it) }) { include 'Capsule.class' } // we just need the single Capsule class
    // from(zipTree(jar.archivePath)) { include 'MyCapsule.class' } // - if we want a custom capsule

    from jar // embed our application jar
    from { configurations.runtime } // embed dependencies

    manifest {
        attributes(
	    'Main-Class'  : 'Capsule', // 'MyCapsule', // - if we want a custom capsule
            'Application-Class' : mainClassName,
            'Min-Java-Version' : '1.8.0',
            'JVM-Args' : run.jvmArgs.join(' '),
            'System-Properties' : run.systemProperties.collect { k,v -> "$k=$v" }.join(' '),
            'Java-Agents' : configurations.quasar.iterator().next().getName()
        )
    }
}

tasks.withType(Jar) {
    doLast { task -> reallyExecutable(task) }
}

def reallyExecutable(jar) {
    ant.concat(destfile: "tmp.jar", binary: true) {
        zipentry(zipfile: configurations.capsule.singleFile, name: 'capsule/trampoline-execheader.sh')
        fileset(dir: jar.destinationDir) {
            include(name: jar.archiveName)
        }
    }
    copy {
        from 'tmp.jar'
        into jar.destinationDir
        rename { jar.archiveName }
    }
    delete 'tmp.jar'
}

//jar {
//    manifest {
//        attributes(
//	    'Main-Class'  : mainClassName,
//        )
//    }
//}


///////// Publish Artifacts
apply plugin: 'maven'

artifacts {
    archives capsule
}

install.dependsOn capsule

task wrapper(type: Wrapper) {
    gradleVersion = '1.11'
}
